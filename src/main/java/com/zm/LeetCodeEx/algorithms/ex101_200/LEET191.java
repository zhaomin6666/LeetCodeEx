package com.zm.LeetCodeEx.algorithms.ex101_200;

/**
 * 191. 位1的个数
 * <p>
 * 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。
 * <p>
 * <p>
 * 提示：
 * 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。
 * 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。
 * <p>
 * 示例 1：
 * 输入：00000000000000000000000000001011
 * 输出：3
 * 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
 * <p>
 * 示例 2：
 * 输入：00000000000000000000000010000000
 * 输出：1
 * 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
 * <p>
 * 示例 3：
 * 输入：11111111111111111111111111111101
 * 输出：31
 * 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
 * <p>
 * 提示：
 * 输入必须是长度为 32 的 二进制串 。
 * <p>
 * 进阶：
 * 如果多次调用这个函数，你将如何优化你的算法？
 *
 * @author zm
 */
public class LEET191 {
    public static void main(String[] args) {
        LEET191 l191 = new LEET191();
        System.out.println(l191.new Solution2().hammingWeight(0b00000000000000000000000000001011));
        System.out.println(l191.new Solution2().hammingWeight(0b11111111111111111111111111111101));
    }

    /**
     * 利用n&(n-1)可以消除最后一个1的特性
     * 在0位居多的情况下效率较高
     */
    public class Solution {
        // you need to treat n as an unsigned value
        public int hammingWeight(int n) {
            int count = 0;
            while (n != 0) {
                n = n & (n - 1);
                count++;
            }
            return count;
        }
    }

    /**
     * 错位分段相加，然后递归合并的过程
     * 原博客1：https://blog.csdn.net/weixin_30587927/article/details/101093369
     * 原博客1的原博客，好像打不开了：http://www.sandy-sp.com/blog/article.asp?id=11
     * <p>
     * 例子，若求156中1的个数，156二进制是10011100
     * 最终：
     * <p>
     * [1][0][0][1][1][1][0][0] //初始，每一位是一组
     * ---
     * |0  0 |0  1 |0  1 |0  0|  //与01010101相与的结果，同时2个一组分组
     * +
     * |0  1 |0  0 |0  1 |0  0|  //右移一位后与01010101相与的结果
     * =
     * [0  1][0  1][1  0][0  0]  //相加完毕后，现在每2位是一组，每一组保存的都是最初在这2位的1的个数
     * ----
     * |0  0  0  1 |0  0  0  0|  //与00110011相与的结果，4个一组分组
     * +
     * |0  0  0  1 |0  0  1  0|  //右移两位后与00110011相与的结果
     * =
     * [0  0  1  0][0  0  1  0] //相加完毕后，现在每4位是一组，并且每组保存的都是最初这4位的1的个数
     * ----
     * |0  0  0  0  0  0  1  0|
     * +
     * |0  0  0  0  0  0  1  0|
     * =
     * [0  0  0  0  0  1  0  0] //最终合并为8位1组，保存的是整个数中1的个数，即4。
     * <p>
     * 其他参考：维基百科 https://www.wiki-wiki.top/wiki/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F
     */
    public class Solution2 {
        public int hammingWeight(int n) {
            n = (n & 0x55555555) + ((n >> 1) & 0x55555555);
            n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
            n = (n & 0x0f0f0f0f) + ((n >> 4) & 0x0f0f0f0f);
            n = (n & 0x00ff00ff) + ((n >> 8) & 0x00ff00ff);
            n = (n & 0x0000ffff) + ((n >> 16) & 0x0000ffff);
            return n;
        }
    }
}
